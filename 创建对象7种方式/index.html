<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>
    /* 一、工厂模式 */
      function createPerson (name, age, job) {
        let o = new Object()
        o.name = name
        o.age = age
        o.job = job
        o.sayName = function () {
          console.log(this.name)
        }
        return o
      }

      let joe = createPerson('joe', 20, 'student')
      joe.sayName() // joe
    /* 工厂模式 缺点：没有解决对象识别的问题（既怎么知道一个对象的类型）*/

    /* 二、构造函数模式 */
      function Person (name, age, job) {
        this.name = name
        this.age = age
        this.job = job
        this.sayName = function () {
          console.log(this.name)
        }
      }

      let joe = new Person('joe', 20, 'student')
      joe.sayName() // joe
    /* 构造函数模式 缺点：方法不是共享的 */

    /* 三、原型模式 */
      function Person () {}
      Person.prototype.name = 'joe'
      Person.prototype.age = 20
      Person.prototype.job = 'student'
      Person.prototype.sayName = function () {
        console.log(this.name)
      }
      let joe = new Person()
      joe.sayName() // joe

      console.log(joe.__proto__ === Person.prototype) // true
      console.log(Object.getPrototypeOf(joe) === Person.prototype) // true
      console.log(Person.prototype.isPrototypeOf(joe)) // true
      console.log(joe instanceof Person) // true
      console.log(joe.constructor === Person) // true

      console.log(joe.hasOwnProperty('name')) // false 因为hasOwnProperty是用来判断自身的有没有这个属性的，原型链上的不算
      joe.name = 'other joe'
      console.log(joe.hasOwnProperty('name')) // true
      delete joe.name
      console.log(joe.hasOwnProperty('name')) // false
      console.log('name' in joe) // true in操作符会顺着原型链往上找
    /* 原型模式 缺点：省略了为构造函数传递初始化参数这个环节，所有实例在默认的情况下都取得相同的属性值 */

    /* 四、组合使用构造函数和原型模式 */
      function Person (name, age, job) {
        this.name = name
        this.age = age
        this.job = job
      }
      Person.prototype = {
        constructor: Person,
        sayName: function () {
          console.log(this.name)
        }
      }

      let joe = new Person('joe', 20, 'student')
      joe.sayName()
    /* 组合使用构造函数和原型模式 优点：每个实例都有每个实例的属性副本，而且方法还是共享的（所有实例里面的原型链方法都是对应的一个引用）*/
  </script>
</body>
</html>